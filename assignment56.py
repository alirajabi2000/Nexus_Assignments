# -*- coding: utf-8 -*-
"""AI–DS Nexus | A0.4. Linear Algebra (vectors, matrices)| RezaShokr.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kJMH2nllXHJJM6u7Ey-qBl09_i0rDO_L

# 📓 Assignment 4 — Linear Algebra Fundamentals

*Vectors & Matrices for Everyday Coding*

## Welcome back, intrepid coder! 🚀
In this notebook-styled brief you’ll move from single-direction vectors to multi-direction matrices—core tools behind graphics, robotics, optimisation and (of course) machine-learning. Each mini-section mixes quick notes, a tiny real-world scenario, and hands-on # TODO code shaped for beginners.

## 🧭 Vectors 101

| Concept             | Quick reminder                                  |
|---------------------|--------------------------------------------------|
| Representation      | 1-D NumPy array — `np.array([x, y, z])`         |
| Length (norm)       | `np.linalg.norm(v)`                             |
| Dot / inner product | `v.dot(w)` or `np.inner(v, w)`                  |
| Unit vector         | `v / np.linalg.norm(v)`                         |
"""

# Run once per session
import numpy as np
x1, y1, z1 = [1,2,3]
v = np.array([x1, y1, z1])
length_v = np.linalg.norm(v)
print("length of v : ", length_v)
x2, y2, z2 = [4, 5, 6]
w = np.array([x2, y2, z2])
print("dot v va w :", np.dot(v, w))

"""### 🚁 Practical Scenario — “Drone hop”
A mini-drone lifts off at (2 m, 1 m) and lands at (7 m, 4 m).
Calculate its displacement vector, travel distance, and orientation along the x-axis.
"""

p_start = np.array([2, 1])
p_end   = np.array([7, 4])

# displacement
d = p_end - p_start          # ➡️ vector from start to end
dist = np.linalg.norm(d)     # 🏁 distance travelled
unit = d / dist              # ↗️ unit direction
dot_x = d.dot(np.array([1, 0]))  # projection on x-axis

print("Displacement:", d)
print("Distance:", dist)
print("Unit direction:", unit)
print("Dot-product with x-axis:", dot_x)

"""## 🔢 Matrices 101

| Operation              | NumPy one-liner                                  |
|------------------------|--------------------------------------------------|
| Transpose              | `A.T`                                            |
| Determinant            | `np.linalg.det(A)`                               |
| Inverse                | `np.linalg.inv(A)` (works only if `det(A) ≠ 0`)  |
| Matrix-vector multiply | `A @ v`                                          |
| Matrix-matrix multiply | `A @ B`                                          |

"""

import numpy as np
A = np.array([[1 , 2], [3, 4]])
det_A = np.linalg.det(A)
print("det A IS :", det_A)
if det_A !=0 :
  inv_A = np.linalg.inv(A)
  print("inverse A IS :\n", inv_A)
else:
  print("matrix is not invertible.")

"""### 🎯 Practical Scenario — “Rotate that hop”
Rotate the drone’s displacement vector 30° counter-clockwise, then verify that the inverse rotation brings it back.
"""

theta = np.deg2rad(30)          # 🔄 convert degrees to radians
R = np.array([[np.cos(theta), -np.sin(theta)],
              [np.sin(theta),  np.cos(theta)]])

det_R = np.linalg.det(R)        # should be 1.0 (pure rotation)
d = [1, 0]
d_rot  = R @ d                  # rotated displacement
d_back = np.linalg.inv(R) @ d_rot

print("Rotation matrix determinant:", det_R)
print("Rotated vector:", d_rot)
print("Back-rotated equals original?", np.allclose(d_back, d))